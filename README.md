Logging:

-Logging can be used to monitor your application flow, and it is a good way to capture
unexpected errors in your program code. Spring Boot starter packages provide a logback
that we can use for logging without any configuration

-private static final Logger logger = LoggerFactory.getLogger
-The logger.info method prints a logging message in the console

-If we set the logging level to DEBUG, we can see log messages from levels that are log level
DEBUG or higher

-DI is a software development technique where we can create objects that depend on other
objects
-There are three types of classes in DI:
-A service is a class that can be used (this is the dependency)
-The client is a class that uses the dependency
-The injector passes the dependency (the service) to the dependent class (the client)
-Constructor injection: Dependencies are passed to a client class constructor.
An example of the constructor injection was already shown in the preceding Car
example code
-Setter injection: Dependencies are provided through setters. The following example
code shows an example of the setter injection

Queries:
-You can define your queries in the Spring Data repositories. The query must start
with a prefix
-Queries can be sorted by using the OrderBy keyword in the query method
-You can also create queries by using SQL statements via the @Query annotation
-FetchType
defines the strategy for fetching data from the database
-The @OneToMany annotation has two attributes that we are using. The cascade
attribute defines how cascading affects the entities in the case of deletions or
updates. The ALL attribute setting means that all operations are cascaded. For
example, if the owner is deleted, the cars that are linked to that owner are deleted as
well. The mappedBy="owner" attribute setting tells us that the Car class has the
owner field, which is the foreign key for this relationship


REST
-Rest stands for Representational State Transfer
-Stateless: The server doesn't hold any information about the client state
-Client: The client and server act independently. The server does not send any
information without a request from the client
-Cacheable: Many clients often request the same resources; therefore, it is useful to
cache responses in order to improve performance
-Uniform interface: Requests from different clients look the same. Clients may
include, for example, a browser, a Java application, and a mobile application.
-Layered system: REST allows us to use a layered system architecture
-Code on demand: This is an optional constraint

-Every REST architecture should have the following elements
-Identification of resources: There are resources with their unique identifiers, for
example, URIs in web-based REST services. REST resources should expose easily
understood directory structure URIs. Therefore, a good resource naming strategy is
very important
-Resource manipulation through representation: When making a request to
a resource, the server responds with a representation of the resource. Typically, the
format of the representation is JSON or XML
-Self-descriptive messages: Messages should have sufficient information that the
server knows how to process them
-Hypermedia as the Engine of Application State (HATEOAS): Responses can
contain links to other areas of service

-@RequestMapping annotation defines the endpoint that the method is mapped to
-@JsonIgnoreProperties annotation  ignores the  fields that are generated by Hibernate
-The HAL format provides a set of conventions for expressing hyperlinks in
JSON and it makes your RESTful web service easier to use for frontend developers
-If you are using PATCH, you have to send only fields that are updated. If you are using PUT, you have to include all fields in the request body


Spring security
-spring security requires a dependency
-When you start your application, you can see from the console that Spring Security has
created an in-memory user with a username of user
-To configure how Spring Security behaves, we have to add a new configuration class
that extends WebSecurityConfigurerAdapter
-s. The
@Configuration and @EnableWebSecurity annotations switch off the default web
security configuration, and we can define our own configuration in this class.

JJWT
-The jjwt library is used for creating and parsing JWTs:
-needs a dependency

Deploying
-If you use Maven, an executable JAR file can be created using the Spring Boot Maven plugin (pom file)
-right-clicking Project in the project explorer, selecting Run as  Maven Build and typing clean install in the Goals field
-you don't have to install a separate application server, because it is embedded in your JAR file
-Heroku offers a free account that you can use to deploy your own applications
-Change the database connection definition in the application.properties file to the values from the JawsDB Connection Info page

Docker containers
-Docker is a container platform that makes software development, deployment, and shipping easier
-Install Docker on your workstation
-uses JAR file
-Containers are defined by using Dockerfiles
-Create a container with the following command docker build -t carbackend
-Run the container with the following command docker run -p 4000:8080 carbackend
-# FullStackNotes
